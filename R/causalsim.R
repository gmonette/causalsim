#' causalsim: A package to explore linear causal DAGs
#' 
#' The causalsim package uses a matrix containing the 
#' coefficients and standard deviations of the unique
#' independent components of a linear causal
#' DAG to generate the marginal covariance matrix and to 
#' calculate the value of coefficients of
#' linear models applied to a population generated by
#' the causal DAG.  
#' 
#' See \code{\link{coefx}} for an extended example.
#' 
#' @docType package
#' @name causalsim
NULL


#' Transform a matrix of causal coefficients to a DAG
#' 
#' A square matrix containing causal coefficients with 
#' standard deviation of unique components on the
#' diagonal is transformed into a lower-triangular
#' matrix by permutations of its rows and columns,
#' if possible. Otherwise an error is produced.
#' 
#' See \code{\link{coefx}} for an extended example.
#'
#' @param mat a square matrix with variable names
#'        for rows and columns. Off-diagonal entries
#'        are causal coefficients for the row
#'        variable depending on the column variables.
#'        The diagonal elements are standard deviations
#'        of the the independent component producing
#'        variability in the row variable. 
#' @return If the input matrix represents a DAG,
#'        the input matrix with permuted rows and
#'        columns as a lower diagonal matrix. Thus
#'        data from the DAG can be generated by
#'        simulating variables in the same order
#'        as the row order. If the input matrix
#'        cannot define a DAG (i.e. is not
#'        acyclic) the function return FALSE
#'        with an error message.
#' @export
to_dag <- function(mat){
  # check that mat has unique column and row names
  find_leaves <- function(m) {
    sumabs <- function(x) sum(abs(x))
    diag(m) <- 0 # in case they're used for epsilons
    which(apply(m,2,sumabs)==0)
  }
  if(nrow(mat) != ncol(mat)) stop('matrix must be square')
  if(any(sort(colnames(mat)) != sort(rownames(mat)))) stop('colnames not same as rownames')
  if(length(unique(colnames(mat))) != length(colnames(mat))) stop('names not unique')
  mat <- mat[colnames(mat), colnames(mat)]
  if(sum(abs(mat[row(mat) < col(mat)])) == 0) {
    # matrix already lower diagonal  
    class(mat) <- unique(c('dag', class(mat)))
    return(mat)
  }
  ret <- mat
  dag_perm <- rep('', nrow(mat))
  for(i in 1:nrow(ret)) {
    # disp(i)
    # disp(mat)
    ll <- find_leaves(mat)
    if(length(ll) == 0) return(FALSE)
    dag_perm[i] <- names(ll[1])
    # disp(dag_perm)
    if(i < nrow(ret)) mat <- mat[-ll[1],-ll[1], drop = FALSE]
  }
  ret <- ret[rev(dag_perm),rev(dag_perm)]
  class(ret) <- unique(c('dag', class(ret)))
  ret
}

#' Synonym for to_dag
#' 
#' @rdname to_dag
#' @export
permute_to_dag <- to_dag




#' Simulate a data frame from a DAG
#' 
#' Simulates a data frame from the multivariate normal
#' distribution generated by a DAG
#' 
#' @param dag a lower triangular matrix representing a
#'        DAG or a matrix that can be permutted into
#'        such a matrix.
#' @param n the number of observations to generate.
#' @return a data frame with one column for each
#'        variable in the DAG. The variables are
#'        generated from a multivariate normal 
#'        distribution with mean zero
#'        and variance matrix implied by the 
#'        coefficients of the DAG.
#' @importFrom stats rnorm
#' @export
sim <- function(dag, n) {
    fac <- function(x) {
        xx <- svd(x, nu = 0)
        t(xx$v) * sqrt(pmax(xx$d, 0))
    }
	dag <- to_dag(dag)
	v <- covld(dag)
	E <- matrix(rnorm(n*ncol(dag)), nrow = n, ncol = ncol(dag))
	ret <- as.data.frame(E%*%fac(v))
	names(ret) <- colnames(dag)
	ret
}

#' Plot a causal graph
#' 
#' Uses \code{\link[ggdag]{ggdag}} to plot the graph of a DAG.
#' 
#' @param x a lower-triangular matrix representing a DAG. In
#'        constrast with other function, the `x` argument must
#'        have class 'dag' and, so, must have been constructed
#'        with \code{\link{to_dag}}.
#' @param ... passed to \code{\link[ggdag]{ggdag}}.
#' @return plots a causal graph with \code{\link[ggdag]{ggdag}}.
#' @importFrom dagitty dagitty
#' @importFrom ggdag ggdag
#' @export
plot.dag <- function(x, ...) {
  dag <- x
  makedagitty <- function(mat) {
    string <- ''
    Var1 <- Var2 <- Freq <- 0   # make check happy
    df <- as.data.frame(as.table(dag))
    df <- subset(df, Var1 != Var2)
    df <- subset(df, Freq > 0)
    for(i in seq_len(nrow(df))) {
      string <- paste(string,' ',df[i,'Var1'],' <- ', df[i,'Var2'] )
    }
    string <- paste('dag{', string, '}')
    dagitty::dagitty(string)
  }
  ggdag::ggdag(makedagitty(dag), ...)
}  
